<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0">
  <meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Cache-Control" content="no-cache">

  <title>牡蠣サーモンキャッチゲーム</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #f0f0f0;
    }

    #main {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100%;
      height: 100vh;
      position: relative;
    }

    #main .main_wrap {
      width: 100%;
      max-width: 480px;
      height: 100%;
      max-height: 640px;
      margin: auto;
      position: relative;
      perspective: 1000px;
      overflow: hidden;
      background: url("images/start.png") no-repeat center center;
      background-size: 100% auto;
    }

    canvas {
      display: block;
      margin: auto;
      position: relative;
      z-index: 1;
    }

    #bgLayer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: url("images/default_bg.png");
      background-size: cover;
      background-position: center;
      transition: transform 0.6s ease;
      transform-style: preserve-3d;
      backface-visibility: hidden;
    }

    #startScreen,
    #gameOverScreen,
    #clearScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      background: url("images/start.png") no-repeat center center;
      color: white;
      z-index: 10;
      padding: 10% 15%;
      box-sizing: border-box;
      color: rgb(52, 52, 52);
      background-size: 100% 100%;
    }

    #startScreen {
      background-image: url("images/start.png");
    }

    #gameOverScreen {
      background-image: url("images/gameover.png");
    }

    #clearScreen {
      background-image: url("images/clear.png");
    }

    #hearts {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      gap: 5px;
      z-index: 2;
    }

    #hearts img {
      width: 30px;
      height: 30px;
    }

    #score {
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 24px;
      z-index: 3;
    }

    #controls {
      position: absolute;
      bottom: 20px;
      width: 100%;
      display: flex;
      justify-content: space-between;
      padding: 0 20px;
      box-sizing: border-box;
    }

    .ctrl-btn {
      width: 60px;
      height: 60px;
      background: rgba(0, 0, 0, 0.5);
      color: white;
      font-size: 24px;
      border: none;
      border-radius: 50%;
      user-select: none;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #leftRight {
      display: flex;
      gap: 20px;
    }

    .btn {
      display: block;
      width: 100%;
      background: #0054ed;
      color: #FFF;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 3em;
      font-size: 20px;
      border-radius: 5px;
      margin-top: 10px;
      cursor: pointer;
      transition: opacity 0.3s ease;
      user-select: none;
    }

    .btn:hover {
      opacity: .7;
    }

    h1 {
      color: #0054ed;
    }
    #score , #hearts ,h1 , h1 + p , p.img ,#finalClearScore , #finalScore{
      user-select: none;
    }
    @media (max-width: 479px) {
      #main .main_wrap {
        margin: 0 auto auto;
        max-height: none;
        height: auto;
       aspect-ratio: 3 / 4;
      }
        canvas {
        width: 100%;
        height: auto;
      }
      #startScreen img,
      #gameOverScreen img,
      #clearScreen img {
        width: 70%;
        display: block;
        margin: 0 auto;
      }
      h1 {
        font-size: 7vw;
      }
      h1 + p,
      .btn {
        font-size: 3.5vw;
      }
    }
  </style>
</head>

<body>
  <div id="main">
    <div class="main_wrap">
      <!-- スタート画面 -->
      <div id="startScreen">
        <h1>牡蠣サーモンキャッチ</h1>
        <p>みくちゃんの好きな牡蠣やサーモン寿司をたくさん集めてみくちゃんに会いに行こう！</p>
        <p class="img"><img src="images/start_img.png" alt=""></p>
        <a id="startBtn" class="btn">遊ぶ</a>
      </div>
      <!-- ゲームオーバー画面 -->
      <div id="gameOverScreen" style="display:none;">
        <h1 id="endTitle">ゲームオーバー</h1>
        <p class="img"><img src="images/gameover_img.png" alt=""></p>
        <p id="finalScore"></p>
        <a class="btn" id="retryBtn">リトライ</a>
        <a class="btn" id="backToStartBtn">スタートに戻る</a>
      </div>
      <!-- ゲームクリア画面 -->
      <div id="clearScreen" style="display:none;">
        <h1 id="clearTitle">ゲームクリア！</h1>
        <p class="img"><img src="images/clear_img.png" alt=""></p>
        <p id="finalClearScore"></p>
        <a class="btn" id="retryBtn_agein">もう一度</a>
        <a class="btn" id="backToStartBtn_top">スタートに戻る</a>
      </div>

      <div id="bgLayer"></div>
      <canvas id="gameCanvas" width="480" height="640"></canvas>
      <div id="hearts"></div>
      <div id="score">Score: 0</div>
    </div>
  </div>

  <!-- スマホ用コントローラー -->
  <div id="controls" style="display:none;">
    <div id="leftRight">
      <a class="ctrl-btn" id="leftBtn">←</a>
      <a class="ctrl-btn" id="rightBtn">→</a>
    </div>
    <a class="ctrl-btn" id="jumpBtn">⤴</a>
  </div>

  <script>
    // ========= 画像 =========
    const IMG_PATHS = {
      player: "images/player.png",
      candy: "images/candy.png",
      donut: "images/donut.png",
      bomb: "images/bomb.png",
      heart: "images/heart.png",
      heartEmpty: "images/heart_empty.png",
      star: "images/star.png"
    };

    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    // ========= 音楽 =========
    const sounds = {
      jump: new Audio("sounds/jump.mp3"),
      damage: new Audio("sounds/damage.mp3"),
      item: new Audio("sounds/item.mp3"),
      heart: new Audio("sounds/heart.mp3"),
      gameover: new Audio("sounds/gameover.mp3"), // ゲームオーバー用
      clear: new Audio("sounds/clear.mp3"),       // クリア用
      bgm: new Audio("sounds/bgm.mp3")
    };

    // 音を重ねて鳴らすために毎回 clone して再生
    function playSound(audio) {
      const s = audio.cloneNode();
      s.volume = 0.4; // 音量調整
      s.play();
    }

    // ループ再生設定
    sounds.bgm.loop = true;
    sounds.bgm.volume = 0.1; // 音量調整（0.0〜1.0）

    // ========= 背景管理 =========
    const bgImages = [
      "images/bg01.png",
      "images/bg02.png",
      "images/bg03.png",
      "images/bg04.png",
      "images/bg05.png"
    ]; // ランダムに使う背景画像

    const bgLayer = document.getElementById("bgLayer");
    let shuffledImages = [];

    // シャッフル関数（Fisher–Yates）
    function shuffleArray(array) {
      let arr = array.slice();
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function setBackgroundShuffledWithFlip() {
      // 画像が尽きたら再シャッフル
      if (shuffledImages.length === 0) {
        shuffledImages = shuffleArray(bgImages);
      }

      // 次の画像を取り出し
      const img = shuffledImages.shift();

      // 0 → 180度 回転（裏側へ）
      bgLayer.style.transform = "rotateY(180deg)";

      setTimeout(() => {
        // 画像を切り替え
        bgLayer.style.backgroundImage = `url(${img})`;

        // 360度まで回転して正面に戻す
        bgLayer.style.transform = "rotateY(360deg)";
      }, 300);
    }

    function resetBackgroundWithFlip() {
      // 0 → 180度 回転
      bgLayer.style.transform = "rotateY(180deg)";

      setTimeout(() => {
        // 裏側でデフォルト画像に切り替え
        bgLayer.style.backgroundImage = "url('images/default_bg.png')";

        // 360度に戻す
        bgLayer.style.transform = "rotateY(360deg)";
      }, 300);
    }

    // ========= グローバル =========
    let player, items, score, lives, gameInterval, dropInterval, speedMultiplier, gameRunning = false;
    let eventTimer, eventPhase = 0, katakanaIndex = 0;
    const gravity = 1;

    // ========= プレイヤー =========
    class Player {
      constructor() {
        this.x = canvas.width / 2 - 25;
        this.y = canvas.height - 60;
        this.width = 42; this.height = 50;
        this.dy = 0;
        this.jumpPower = -15;
        this.onGround = true;
        this.image = new Image(); this.image.src = IMG_PATHS.player;
      }

      draw() { ctx.drawImage(this.image, this.x, this.y, this.width, this.height); }

      jump() {
        if (this.onGround) {
          this.dy = this.jumpPower;
          this.onGround = false;
          playSound(sounds.jump);
        }
      }

      update() {
        // 横移動（押しっぱなし対応）
        if (leftPressed) this.x = Math.max(0, this.x - 5);
        if (rightPressed) this.x = Math.min(canvas.width - this.width, this.x + 5);

        // 重力 & ジャンプ
        this.dy += gravity;
        this.y += this.dy;

        if (this.y + this.height >= canvas.height) {
          this.y = canvas.height - this.height;
          this.dy = 0;
          this.onGround = true;
        }

        this.draw();
      }
    }
    // ========= アイテム =========
    class Item {
      constructor(type, x, y, speed = 3) {
        this.type = type;
        this.x = x; this.y = y;
        this.width = 30; this.height = 30;
        this.speed = speed * speedMultiplier;
        this.image = new Image(); this.image.src = IMG_PATHS[type];
      }
      draw() { ctx.drawImage(this.image, this.x, this.y, this.width, this.height); }
      update() { this.y += this.speed; this.draw(); }
    }

    // ========= ハート =========
    function updateHearts() {
      const heartsDiv = document.getElementById("hearts");
      heartsDiv.innerHTML = "";
      for (let i = 0; i < 3; i++) {
        const img = document.createElement("img");
        img.src = (i < lives) ? IMG_PATHS.heart : IMG_PATHS.heartEmpty;
        heartsDiv.appendChild(img);
      }
    }

    // ========= アイテム生成 =========
    function spawnItem() {
      if (inKatakanaEvent) return; // ★ イベント③中は通常アイテム出さない
      const rand = Math.random(); let type;
      if (rand < 0.4) type = "candy"; else if (rand < 0.8) type = "donut"; else type = "bomb";
      items.push(new Item(type, Math.random() * (canvas.width - 30), -30));
    }

    // ========= 特殊パターン =========
    function spawnPatternRow() {
      const cols = Math.floor(canvas.width / 30);
      const hole = Math.floor(Math.random() * (cols - 2)); // 3マス分空けるので -2
      for (let i = 0; i < cols; i++) {
        if (i < hole || i > hole + 2) {  // 3マス連続を穴にする
          items.push(new Item("bomb", i * 30, -30, 3));
        }
      }
    }

    // カタカナ形状定義（7×7ドット、1マス=30px）
    const katakanaPatterns = {
      "フ": [
        [0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1],
        [5, 2],
        [5, 3],
        [4, 4],
        [3, 5],
        [1, 6], [2, 6]
      ].map(([x, y]) => [x * 30, y * 30]),

      "ジ": [
        [0, 0], [2, 0], [4, 0], [6, 0],
        [1, 1],
        [0, 2], [4, 2],
        [1, 3], [5, 3],
        [4, 4],
        [3, 5],
        [0, 6], [1, 6], [2, 6]
      ].map(([x, y]) => [x * 30, y * 30]),

      "サ": [
        [2, 0], [4, 0],
        [0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1], [6, 1],
        [2, 2], [4, 2],
        [2, 3], [4, 3],
        [5, 4],
        [4, 5],
        [2, 6], [3, 6]
      ].map(([x, y]) => [x * 30, y * 30]),

      "キ": [
        [3, 0],
        [1, 1], [2, 1], [3, 1], [4, 1], [5, 1],
        [3, 2],
        [3, 3],
        [1, 4], [2, 4], [3, 4], [4, 4], [5, 4], [6, 4],
        [3, 5],
        [3, 6]
      ].map(([x, y]) => [x * 30, y * 30]),

      "ミ": [
        [1, 0], [2, 0], [3, 0],
        [4, 1], [5, 1],
        [2, 2],
        [3, 3], [4, 3],
        [1, 5], [2, 5], [3, 5],
        [4, 6], [5, 6]
      ].map(([x, y]) => [x * 30, y * 30]),

      "ク": [
        [2, 0],
        [2, 1], [3, 1], [4, 1], [5, 1],
        [1, 2], [5, 2],
        [0, 3], [6, 3],
        [4, 4],
        [3, 5],
        [1, 6], [2, 6]
      ].map(([x, y]) => [x * 30, y * 30]),

      "オ": [
        [4, 0],
        [0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1], [6, 1],
        [4, 2],
        [3, 3], [4, 3],
        [2, 4], [4, 4],
        [0, 5], [1, 5], [4, 5],
        [3, 6], [4, 6]
      ].map(([x, y]) => [x * 30, y * 30]),

      "タ": [
        [2, 0],
        [2, 1], [3, 1], [4, 1], [5, 1],
        [1, 2], [5, 2],
        [0, 3], [2, 3], [4, 3], [6, 3],
        [4, 4],
        [3, 5],
        [1, 6], [2, 6]
      ].map(([x, y]) => [x * 30, y * 30]),

      "ン": [
        [1, 0],
        [2, 1],
        [6, 2],
        [6, 3],
        [5, 4],
        [4, 5],
        [1, 6], [2, 6], [3, 6]
      ].map(([x, y]) => [x * 30, y * 30]),

      "ョ": [
        [1, 2], [2, 2], [3, 2], [4, 2],
        [4, 3],
        [2, 4], [3, 4], [4, 4],
        [4, 5],
        [1, 6], [2, 6], [3, 6], [4, 6]
      ].map(([x, y]) => [x * 30, y * 30]),

      "ウ": [
        [2, 0],
        [0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1],
        [0, 2], [5, 2],
        [5, 3],
        [4, 4],
        [3, 5],
        [1, 6], [2, 6]
      ].map(([x, y]) => [x * 30, y * 30]),

      "ビ": [
        [0, 0], [3, 0], [5, 0], [7, 0],
        [0, 1],
        [0, 2], [3, 2], [4, 2],
        [0, 3], [1, 3], [2, 3], [3, 3],
        [0, 4],
        [0, 5],
        [1, 6], [2, 6], [3, 6], [4, 6], [5, 6]
      ].map(([x, y]) => [x * 30, y * 30]),

      "メ": [
        [5, 0],
        [5, 1],
        [1, 2], [2, 2], [3, 2], [5, 2],
        [4, 3],
        [3, 4], [5, 4],
        [2, 5], [5, 5],
        [0, 6], [1, 6]
      ].map(([x, y]) => [x * 30, y * 30]),

      "デ": [
        [1, 0], [2, 0], [3, 0], [4, 0], [6, 0],
        [0, 2], [1, 2], [2, 2], [3, 2], [4, 2], [5, 2], [6, 2],
        [3, 3],
        [3, 4],
        [3, 5],
        [2, 6]
      ].map(([x, y]) => [x * 30, y * 30]),

      "ト": [
        [2, 0],
        [2, 1],
        [2, 2],
        [2, 3], [3, 3], [4, 3],
        [2, 4], [4, 4],
        [2, 5],
        [2, 6]
      ].map(([x, y]) => [x * 30, y * 30])
    };

    // ========= 出す順番（単語リスト） =========
    const katakanaWords = [
      ["フ", "ジ", "サ", "キ", "ミ", "ク"],
      ["オ", "タ", "ン", "ジ", "ョ", "ウ", "ビ"],
      ["オ", "メ", "デ", "ト", "ウ"]
    ];

    let katakanaPatternIndex = 0; // どの単語を出すか管理

    function spawnKatakana(char, isLastChar = false) {
      const pattern = katakanaPatterns[char];
      const startX = canvas.width / 2 - 90; // 中央寄せ

      // ★ ランダムでハートを置く位置を決める（ただし lives < 3 の場合のみ）
      let heartIndex = -1;
      if (isLastChar && lives < 3) {
        heartIndex = Math.floor(Math.random() * pattern.length);
      }

      pattern.forEach(([dx, dy], idx) => {
        let type = "star"; // 基本は星
        if (idx === heartIndex) {
          type = "heart";
        }
        items.push(new Item(type, startX + dx, dy - 100, 3));
      });
    }

    // ========= イベント進行 =========
    let eventTimers = []; // タイマー管理用
    let inKatakanaEvent = false; // ★ フラグ追加

    function scheduleEvents() {
      clearEventTimers(); // ← 念のため最初でクリア

      const runEvent = () => {
        eventPhase++;
        if (eventPhase % 3 === 1) {
          // ① 横一列
          spawnPatternRow();
          eventTimers.push(setTimeout(runEvent, 20000)); // 20秒後に②
        }
        else if (eventPhase % 3 === 2) {
          // ② 3回連続（5秒ごと）
          let count = 0;
          const int = setInterval(() => {
            spawnPatternRow();
            if (++count >= 3) {
              clearInterval(int);
              eventTimers.push(setTimeout(runEvent, 20000)); // 20秒後に③
            }
          }, 5000);
          eventTimers.push(int); // intervalも管理
        }
        else if (eventPhase % 3 === 0) {
          // ③ カタカナ文字（順番に単語を使用）
          inKatakanaEvent = true; // ★ 開始時にフラグON
          katakanaIndex = 0;
          const chars = katakanaWords[katakanaPatternIndex];

          // ★背景をランダムにフリップ変更
          setBackgroundShuffledWithFlip();

          const nextChar = () => {
            if (!gameRunning) return;
            if (katakanaIndex < chars.length) {
              const isLastChar = (katakanaIndex === chars.length - 1);
              spawnKatakana(chars[katakanaIndex], isLastChar); // ←追加
              katakanaIndex++;
              const t = setTimeout(nextChar, 2000); // ★ 変数に入れる
              eventTimers.push(t);                  // ★ 管理リストに追加
            } else {
              resetBackgroundWithFlip();
              // ★ イベント③終了 → フラグOFF
              inKatakanaEvent = false;
              const t = setTimeout(runEvent, 10000); // ★ 変数に入れる
              eventTimers.push(t);                   // ★ 管理リストに追加
              katakanaPatternIndex = (katakanaPatternIndex + 1) % katakanaWords.length;
            }
          };
          nextChar();
        }
      };

      // 初回は20秒待ってから①を発生
      eventTimers.push(setTimeout(runEvent, 20000));
    }



    // ========= ゲーム進行 =========
    let gameStartTime = Date.now();
    let speedLevel = 3;  // 初期スピード

    function gameLoop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      player.update();

      // 経過時間でスピード調整
      const elapsed = Math.floor((Date.now() - gameStartTime) / 1000);
      const newSpeed = 3 + Math.floor(elapsed / 20); // 20秒ごとに+1
      if (newSpeed !== speedLevel) {
        speedLevel = newSpeed;
        adjustDropRate(); // 出現間隔も調整
      }

      items.forEach((item, i) => {
        item.speed = speedLevel * (downPressed ? 2 : 1);  // ★ 下キーで倍速
        item.update();
        if (collision(player, item)) {
          if (item.type === "candy") {
            score += 3;
            playSound(sounds.item);
          } else if (item.type === "donut") {
            score += 10;
            playSound(sounds.item);
          } else if (item.type === "star") {
            score += 50000000;
            playSound(sounds.item);
          } else if (item.type === "heart") {
            if (lives < 3) { // ★ 最大値以上は増えない
              lives++;
              updateHearts();
            }
            playSound(sounds.heart);
            items.splice(i,1);
          } else {
            lives--;
            updateHearts();
            playSound(sounds.damage);
            if (lives <= 0) endGame("ゲームオーバー");
          }
          items.splice(i, 1);
        } else if (item.y > canvas.height) {
          items.splice(i, 1);
        }
      });

      // スコア更新
      document.getElementById("score").textContent = "Score: " + score;

      // ★ クリア判定
      if (score >= 10000000000) {
        endGame("ゲームクリア！");
      }
    }

    function collision(a, b) {
      return a.x < b.x + b.width && a.x + a.width > b.x && a.y < b.y + b.height && a.y + a.height > b.y;
    }

    function clearEventTimers() {
      eventTimers.forEach(t => {
        clearTimeout(t);
        clearInterval(t);
      });
      eventTimers = [];
    }

    // ========= ゲーム開始/終了 =========
    function initGame() {
      player = new Player(); items = []; score = 0; lives = 3; speedMultiplier = 1;
      eventPhase = 0; katakanaIndex = 0;
      katakanaPatternIndex = 0; // ← これも忘れず
      inKatakanaEvent = false;  // ← 念のためリセット
      clearEventTimers();       // ← タイマー完全消去

      document.getElementById("score").textContent = "Score: 0";
      updateHearts();

      // 両方の画面を消す
      document.getElementById("gameOverScreen").style.display = "none";
      document.getElementById("clearScreen").style.display = "none";
    }

    function startGame() {
      document.getElementById("startScreen").style.display = "none";
      document.getElementById("gameOverScreen").style.display = "none";
      if (/Mobi|Android/i.test(navigator.userAgent)) {
        document.getElementById("controls").style.display = "flex";
      }
      initGame(); gameRunning = true;
      gameStartTime = Date.now();

      gameInterval = setInterval(gameLoop, 30);
      adjustDropRate(); // 最初の出現間隔をセット

      clearEventTimers();   // ← 前回のタイマーを必ず削除
      scheduleEvents();
      // ★ BGM開始
      sounds.bgm.currentTime = 0;
      sounds.bgm.play();
    }

    function endGame(status = "ゲームオーバー") {
      gameRunning = false;
      clearInterval(gameInterval);
      clearInterval(dropInterval);
      clearEventTimers();

      // ★ イベントタイマーを全停止
      eventTimers.forEach(t => clearTimeout(t));
      eventTimers = [];

      document.getElementById("controls").style.display = "none";

      // BGM停止
      sounds.bgm.pause();

      // 効果音
      if (status === "ゲームクリア！") {
        playSound(sounds.clear);
        document.getElementById("clearTitle").textContent = status;
        document.getElementById("finalClearScore").textContent = "Score: " + score;
        document.getElementById("clearScreen").style.display = "flex";
      } else {
        playSound(sounds.gameover);
        document.getElementById("endTitle").textContent = status;
        document.getElementById("finalScore").textContent = "Score: " + score;
        document.getElementById("gameOverScreen").style.display = "flex";
      }
    }

    // ========= アイテム出現間隔調整 =========
    function adjustDropRate() {
      clearInterval(dropInterval);
      // スピードが上がるごとに落下間隔を短縮（下限200ms）
      const dropDelay = Math.max(700 - (speedLevel - 3) * 100, 200);
      dropInterval = setInterval(spawnItem, dropDelay);
    }


    // ========= 操作 =========
    let leftPressed = false;
    let rightPressed = false;
    let downPressed = false;

    document.addEventListener("keydown", e => {
      if (!gameRunning) return;

      if (e.key === "ArrowLeft" || e.key.toLowerCase() === "a") leftPressed = true;
      if (e.key === "ArrowRight" || e.key.toLowerCase() === "d") rightPressed = true;
      if (e.key === "ArrowDown" || e.key.toLowerCase() === "s") downPressed = true;
      if (e.key === " " || e.key === "ArrowUp" || e.key.toLowerCase() === "w") player.jump();
    });

    document.addEventListener("keyup", e => {
      if (e.key === "ArrowLeft" || e.key.toLowerCase() === "a") leftPressed = false;
      if (e.key === "ArrowRight" || e.key.toLowerCase() === "d") rightPressed = false;
      if (e.key === "ArrowDown" || e.key.toLowerCase() === "s") downPressed = false;
    });


    // スマホ操作（タッチ対応）
    document.getElementById("leftBtn").addEventListener("touchstart", () => { if (gameRunning) leftPressed = true; });
    document.getElementById("rightBtn").addEventListener("touchstart", () => { if (gameRunning) rightPressed = true; });
    document.getElementById("jumpBtn").addEventListener("touchstart", () => { if (gameRunning) player.jump(); });

    document.getElementById("leftBtn").addEventListener("touchend", () => { leftPressed = false; });
    document.getElementById("rightBtn").addEventListener("touchend", () => { rightPressed = false; });

    // ========= ボタン =========
    document.getElementById("startBtn").onclick = startGame;
    document.getElementById("retryBtn").onclick = startGame;
    document.getElementById("retryBtn_agein").onclick = startGame;
    document.getElementById("backToStartBtn").onclick = () => {
      document.getElementById("gameOverScreen").style.display = "none";
      document.getElementById("startScreen").style.display = "flex";
    };
    document.getElementById("backToStartBtn_top").onclick = () => {
      document.getElementById("clearScreen").style.display = "none";
      document.getElementById("startScreen").style.display = "flex";
    };
  </script>
</body>


</html>









